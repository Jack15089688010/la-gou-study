<!--
 * @Description: 
 * @Version: 1.0
 * @Autor: c-jack.qian
 * @Date: 2020-11-05 14:48:33
 * @LastEditors: c-jack.qian
 * @LastEditTime: 2021-03-17 18:23:44
-->
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>jack</title>
  </head>
  <style>
    .redItem > label {
      color: #f56c6c;
    }
  </style>
  <script type="text/javascript">
    /*
     1、函数式编程
        a.函数式编程并不是我们程序中的方法或者是函数，他是相当于数学中的一种映射，输入
        相同的数据得到相同的输出的一种函数，用来描述数据之间的映射。
     2、高阶函数 higher-order-function （forEach,map,filter,some...等等）
        2.1 what?
          a.高阶函数就是接受一个或多个作为函数作为参数，可能会返回新的函数的一种的函数

        2.2 how?
          a.作为参数
          const forEach = (array, fn) => {
            for (const item of array) { // 遍历数据对每个元素进行操作
              fn(item)
            }
          }    

          const filter = (array, fn) => { //对满足条件的元素进行过滤
          const cacheList = []; //生命一个数组缓存过滤的元素
          for(item of array){
              if(fn(item)){ //满足条件 放进缓存里面
                cacheList.push(item)
              }
            }
            return cacheList;
          }
          b. 作为返回值
          const onceTest = (fn) => {
            let done = false
            return function(){
              if(!done){
                done = true
                fn.apply(this, arguments)
              }
            }
          } 

          const paytest = onceTest((num) => {
            console.log('支付了:' + num);
          })
          paytest(5)

        2.3 why?
          a.让函数变得更加灵活，不需要考虑内部如何实现，只需要我们实现的目标,他是用来抽象通用的问题
      3、闭包
        3.1 waht
          a. 函数嵌套 内部函数引用外部函数的变量
        3.2 how
          const onceTest = (fn) => {
            let done = false // 这个done 就是闭包
            return function(){
              if(!done){
                done = true
                fn.apply(this, arguments)
              }
            }
          }  
        3.3 why
          a. 优点 可以封装私有变量和属性 
          b. 缺点 不销毁可能会造成内存溢出
      4、纯函数
        4.1 waht
          a. 相同的输入只输出相同的输出，不依赖函数外部任何状态和数据的变化,只依赖其输入的参数
          b. 该函数不会产生任何可观察的副作用（所有的外部交互 例如配置文件， 数据库，获取用户的输入）   
        4.2 why
          a. 因为相同输入得到相同数据，所以可以缓存起来
             案例：
                    function mathRound(num){
                      console.log('计算');
                      return Math.PI * num
                    }
                    
                    const memonize = (fn) => {
                      let cache = {}
                      return function(){
                        const key = JSON.stringify(arguments)
                        cache[key] = cache[key] || fn.apply(fn,arguments) // fn(arguments)直接这样执行不是传num过去，而是传一个arguments对象过去
                        return  cache[key]
                      }
                    }

                    const testFun = memonize(mathRound)
          b. 测试更方便
      5、柯里化
        5.1 what
          a. 当有多个参数，并且有些参数是固定不变时，先传递这些参数调用它，然后返回新的函数接收剩余可变的参数，并且返回结果 
        5.2 how
          模拟原理：
              //手写curry柯里化函数
              const getTotalNum = (a, b, c) => {
                return a + b + c;
              };
              const curry = (fn) => {
                return function curriedFn(...agrs) {
                  // 如果第一次传参的长度小于函数要接受的参数  则继续调用 curriedFn
                  if (fn.length > agrs.length) {
                    return function () {
                      return curriedFn(...agrs.concat(Array.from(arguments)));
                    };
                  }
                  return fn(...agrs);
                };
              };

              const curried = curry(getTotalNum);

              console.log(curried(1)(2, 3));
              console.log(curried()(1, 2, 3));
              console.log(curried(1, 2, 3));

        5.3 why 
          a. 解决硬编码, 当有些参数值固定不变时
            案例：
            function checkAge(age){
              const min = 18 //硬编码 
              return age >= min
            } 
            用柯里化解决 硬编码：
            const checkAgeCurry = (min) => { 
              return function(age){
                return age >= min
              }
            } 
            const checkAge18 = checkAgeCurry(18)
            checkAge18(19)
            // checkAgeCurry(18)(19)
          b. 可以多元函数转换为一元函数，，颗粒度小，函数更灵活，可以组合使用函数产生强大的功能 
      6、函数组合  
        6.1 what
          a. 把多个函数组合起来组成一个新函数
        6.2 how
          a.    
          // 手写函数组合flowRight
            const frist = (arr) => {
              return arr[0];
            };
            const upperCase = (str) => {
              return str.toUpperCase();
            };
            const reverse = (arr) => {
              return arr.reverse();
            };

            const flowRight = (fns) => {
              // reverse改变原来的数组并返回
              // reduce 接受两个参数 1、回调函数，2、初始值 ， 返回处理的结果
              // 回调函数接受两个参数 第一个是汇总值acc，第二个是fns数组里面的一个item值，
              return function (initialValue) {
                return fns.reverse().reduce((acc, fn) => {
                  // acc为上一个函数处理的后的结果值
                  return fn(acc);
                }, initialValue);
              };
            };

            // 柯里化 打印
            const trace = (tip, value) => {
              console.log(tip,value);
              return value
            };
            const traceCurried = curry(trace)
            // 反转 第一个 大写
            const compose = flowRight([upperCase,traceCurried('2') , frist,traceCurried('1') , reverse]);
            const finalValue = compose(["a", "b", "c"]);
            console.log(finalValue);
        6.3 why
          a. 当一个值经过多个函数处理才能得到，这时候就需要一个组合函数
      7、函子Functor
        7.1 what
          a.函子就是一个特殊容器，通过一个普通对象来实现，该对象有map方法，map方法可以运行一个函数对值进行处理（变形关系），让容器中的每个值映射到另一个容器
        7.2 how
          a. 案例：
              //functor函子
              class Container {
                // 静态方法， 不用实例化对象就可以调用
                static of(value){
                  return new Container(value)
                }
                constructor(value){
                  this.value = value;
                }
                // 传入变形关系，将容器中的每个值映射到另一个容器
                map(fn){
                  return Container.map(fn(this.value))
                }
              }
              Container.of(3)
                .map((x) => x + 2)
                .map((x) => x * x);

              //mayBe 函子对外部的空值进行处理
              class Contianer{
                static of(value){
                  return new Contianer(value)
                }
                constructor(value){
                  this.value = value
                }
                map(fn){
                  return this.isNothing() ? Contianer.of(null): Contianer.of(fn(this.value))
                }
                //
                isNothing(){
                  return this.value === null || this.value === undefined
                }
              }
              Contianer.of(null).value

              // Either 函子异常让纯函数变得不纯，用来做异常处理
              class RightEither{
                static of(value){
                  return new RightEither(value)
                }
                constructor(value){
                  this.value = value
                }
                map(fn){
                  return RightEither.of(fn(this.value))
                }
              }
              class LeftEither{
                static of(value){
                  return new LeftEither(value)
                }
                constructor(value){
                  this.value = value
                }
                map(fn){
                  console.log(fn(this.value));
                  return this;
                }
              }

              function parseJson(jsonStr){
                try{
                  console.log(sssf);
                  return RightEither.of(jsonStr)
                }catch (e){ 
                  return LeftEither.of(e.message)
                }
              }
              parseJson('jack').map(value => console.log(value))
              
        7.3 why
          a. 把一些副作用控制在可控的范围内，比如异常处理，异步操作等

     */
  </script>
</html>
