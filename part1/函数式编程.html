<!--
 * @Description: 
 * @Version: 1.0
 * @Autor: c-jack.qian
 * @Date: 2020-11-05 14:48:33
 * @LastEditors: sueRimn
 * @LastEditTime: 2021-03-14 17:22:45
-->
<!DOCTYPE html>

<html>

<head>
  <meta charset="utf-8" />
  <title>jack</title>
</head>
<style>
  .redItem>label {
    color: #f56c6c;
  }
</style>
<script type="text/javascript">
  /*
     1、函数式编程
        a.函数式编程并不是我们程序中的方法或者是函数，他是相当于数学中的一种映射，输入
        相同的数据得到相同的输出的一种函数，用来描述数据之间的映射。
     2、高阶函数 higher-order-function （forEach,map,filter,some...等等）
        2.1 what?
          a.高阶函数就是接受一个或多个作为函数作为参数，可能会返回新的函数的一种的函数

        2.2 how?
          a.作为参数
          const forEach = (array, fn) => {
            for (const item of array) { // 遍历数据对每个元素进行操作
              fn(item)
            }
          }    

          const filter = (array, fn) => { //对满足条件的元素进行过滤
          const cacheList = []; //生命一个数组缓存过滤的元素
          for(item of array){
              if(fn(item)){ //满足条件 放进缓存里面
                cacheList.push(item)
              }
            }
            return cacheList;
          }
          b. 作为返回值
          const onceTest = (fn) => {
            let done = false
            return function(){
              if(!done){
                done = true
                fn.apply(this, arguments)
              }
            }
          } 

          const paytest = onceTest((num) => {
            console.log('支付了:' + num);
          })
          paytest(5)

        2.3 why?
          a.让函数变得更加灵活，不需要考虑内部如何实现，只需要我们实现的目标,他是用来抽象通用的问题
      3、闭包
        3.1 waht
          a. 函数嵌套 内部函数引用外部函数的变量
        3.2 how
          const onceTest = (fn) => {
            let done = false // 这个done 就是闭包
            return function(){
              if(!done){
                done = true
                fn.apply(this, arguments)
              }
            }
          }  
        3.3 why
          a. 优点 可以封装私有变量和属性 
          b. 缺点 不销毁可能会造成内存溢出
      4、纯函数
        4.1 waht
          a. 相同的输入只输出相同的输出，不依赖函数外部任何状态和数据的变化,只依赖其输入的参数
          b. 该函数不会产生任何可观察的副作用（所有的外部交互 例如配置文件， 数据库，获取用户的输入）   
        4.2 why
          a. 因为相同输入得到相同数据，所以可以缓存起来
             案例：
                    function mathRound(num){
                      console.log('计算');
                      return Math.PI * num
                    }
                    
                    const memonize = (fn) => {
                      let cache = {}
                      return function(){
                        const key = JSON.stringify(arguments)
                        cache[key] = cache[key] || fn.apply(fn,arguments) // fn(arguments)直接这样执行不是传num过去，而是传一个arguments对象过去
                        return  cache[key]
                      }
                    }

                    const testFun = memonize(mathRound)
          b. 测试更方便
      5、柯里化
        5.1 what
          a. 当有多个参数，并且有些参数是固定不变时，先传递这些参数调用它，然后返回新的函数接收剩余可变的参数，并且返回结果 
        5.2 how
          模拟原理：
            const getNum = (a, b, c) => {
              return a + b + c
            }

            const curry = (fn) => {
              return function curriedFun (...args) {
                // 对比剩余参数 和 函数接收的参数
                if(args.length < fn.length){
                  // 如果还有剩余参数
                  return function(){
                    // return  fn(...args.concat(Array.from(arguments)))
                    return  curriedFun(...args.concat(Array.from(arguments)))
                  } 
                }
                return fn(...args)
              }
            }

            const getNumCurryFun = curry(getNum)
            console.log(getNumCurryFun(1,2,3));
            console.log(getNumCurryFun(1,2)(3));
            console.log(getNumCurryFun(1)(2,3));

        5.3 why 
          a. 解决硬编码, 当有些参数值固定不变时
            案例：
            function checkAge(age){
              const min = 18 //硬编码 
              return age >= min
            } 
            用柯里化解决 硬编码：
            const checkAgeCurry = (min) => { 
              return function(age){
                return age >= min
              }
            } 
            const checkAge18 = checkAgeCurry(18)
            checkAge18(19)
            // checkAgeCurry(18)(19)
          b. 可以多元函数转换为一元函数，，颗粒度小，函数更灵活，可以组合使用函数产生强大的功能 
      6、函数组合  
        6.1 what
          a.
        6.2 how
          a.
        6.3 why
          a.

     */
  // 手写promise
  // 三种状态 pendding(进行中) rejected(失败) fulfilled(成功) 
  const PENDDING = 'pendding'
  const REJECTED = 'rejected'
  const FULFILLED = 'fulfilled'
  class MyPromise {
    // 构造函数接收一个执行器
    constructor(executor) {
      executor(this.resolve, this.reject)
    }
    status = PENDDING; //初始化状态
    value = ''; //成功值
    reason = null; //失败原因
    successfulCallBackList = []; //用来存储成功回调函数，解决resolve异步问题
    failCallBackList = []; //用来存储失败回调函数，解决reject异步问题
    // 成功回调方法
    resolve = (value) => {
      // 一旦状态发生改变 不可更改
      if (this.status !== PENDDING) return;
      this.status = FULFILLED
      this.value = value;
      while (this.successfulCallBackList.length) this.successfulCallBackList.shift()(this.value);

    }
    // 失败回调方法
    reject = (reason) => {
      // 一旦状态发生改变 不可更改
      if (this.status !== PENDDING) return;
      this.status = REJECTED
      this.reason = reason;
      while (this.failCallBackList.length) this.failCallBackList.shift()(this.reason);
    }
    then = (successCallback, failCallBack) => {
      // 将then方法变成可选参数
      successCallback = successCallback ? successCallback : value => value
      failCallBack = failCallBack ? failCallBack : value => value
      // 判断内部状态status 如果fulfilled就是执行成功回调， rejected就执行失败回调， pendding的话就放进回到队列那里  
      const promise1 = new MyPromise((resovle, reject) => {
        if (this.status === FULFILLED) {
          // 设置settimout的原因是 同步代码的时候获取不到外面的promise 参数
          setTimeout(() => {
            const value = successCallback(this.value)

            // 判断value的值是普通值还是promise对象 如果是普通值直接resolve
            // 如果是promise对象，查看promise的返回结果，，决定调用resolve还是reject
            resolvePromise(value, promise1, resovle, reject)
          }, 0)
        } else if (this.status === REJECTED) {
          const value = failCallBack(this.reason)
          reject(value)
        } else {
          // 解决resolve()是异步时的问题，所以放在队列中
          this.successfulCallBackList.push(successCallback)
          this.failCallBackList.push(failCallBack)
        }
      })
      return promise1;
    }
    // 静态方法不用实例化就可以调用
    static all = (promiseArray) => {
      let result = [] //存放promise回调的结果      
      return new MyPromise((resolve) => {
        let resultLength = 0
        for (let i = 0; i < promiseArray.length; i++) {
          promiseArray[i].then((res) => {
            result[i] = res
            resultLength += 1
            // 为了解决异步
            if (resultLength === promiseArray.length) {
              console.log(result);
              resolve(result)
            };
          })
        }

      });
    }
    static resolve = (value) => {
      return new MyPromise((resolve, reject) => {
        if (value instanceof MyPromise) {
          return value
        } else {
          resolve(value)
        }
      })
    }
    finaly = (fn) => {
      return this.then((res) => {
        // fn(res)
        // return res
        // 如果接收的是promise,
        return MyPromise.resolve(fn()).then(value => value)
      }, (err) => {
        // fn(err)
        // throw err
        return MyPromise.resolve(fn()).then(err => err)
      })
    }
  }

  const resolvePromise = (value, promise, resolve, reject) => {
    // 防止value返回值是自身的promise对象
    if (value === promise) {
      return reject(new TypeError('循环调用了'))
    }
    // 判断value的类型
    if (value instanceof MyPromise) {
      // promise对象
      value.then((thenValue) => {
        return resolve(thenValue)
      }, (err) => {
        return reject(err)
      })
      return;
    };
    // 普通值
    resolve(value)
  }

  const jackPromise = new MyPromise((resolve, reject) => {
    setTimeout(() => {
      resolve('成功了1')
    }, 200)
  })
  jackPromise.finaly((result) => {
    console.log(result);
  }).then((res) => {
    console.log(res);
  },(err) => {
    console.log(err);
  })
</script>

</html>